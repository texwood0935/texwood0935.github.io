[{"title":"NiagaraDataInterface笔记一：如何写一个NDI","url":"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/","content":"<h3 id=\"NDI简介：\"><a href=\"#NDI简介：\" class=\"headerlink\" title=\"NDI简介：\"></a>NDI简介：</h3><pre><code>Niagara是虚幻引擎推出的新的粒子系统\nNiagaraDataInterface就像Component之于Actor一样，能够通过用户自己的实现给Niagara提供许多功能\n</code></pre>\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%871.png\" class=\"\" title=\"UE自带很多NDI提供多种功能给粒子系统使用\">\n\n<h3 id=\"如何写一个NDI：\"><a href=\"#如何写一个NDI：\" class=\"headerlink\" title=\"如何写一个NDI：\"></a>如何写一个NDI：</h3><p>虽然有官方示例 ExampleCustomDataInterface的插件，但是有些函数的作用、以及一些注意点可能还是会有些不清楚。在此我使用一个更加简单的例子，来说明哪些函数的作用。</p>\n<p><strong>Let’s Start</strong></p>\n<ul>\n<li><strong>首先的准备</strong>：<ol>\n<li>我们首先要在对应的模块的build.cs文件中引用<code>Niagara</code>、<code>NiagaraCore</code>两个模块 <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%872.png\" class=\"\" title=\"我们首先要在对应的模块的build.cs文件中引用&#96;Niagara&#96;、&#96;NiagaraCore&#96;两个模块\"></li>\n<li>然后对我们的NiagaraDataInterface，补充UCALSS里的声明，并且实现UObject的<code>PostInitProperties</code>接口 <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UCLASS</span>(EditInlineNew, Category = <span class=\"string\">&quot;MyNiagaraExt&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;My NDI&quot;</span>))</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NIAGARAEXT_API</span> UMyNiagaraDataInterface : <span class=\"keyword\">public</span> UNiagaraDataInterface</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"built_in\">GENERATED_BODY</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">//UObject Interface</span></span><br><span class=\"line\"><span class=\"comment\">//在这里注册NDI，以便在粒子编辑器中能看到我们的NDI</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">PostInitProperties</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//UObject Interface End</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::PostInitProperties</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Super::<span class=\"built_in\">PostInitProperties</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">HasAnyFlags</span>(RF_ClassDefaultObject))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tENiagaraTypeRegistryFlags Flags = ENiagaraTypeRegistryFlags::AllowAnyVariable | ENiagaraTypeRegistryFlags::AllowParameter;</span><br><span class=\"line\">\tFNiagaraTypeRegistry::<span class=\"built_in\">Register</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), Flags);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n 编译打开项目，我们可以在粒子编辑器中看到我们自定义的NDI了 <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%873.png\" class=\"\" title=\"我们可以在粒子编辑器中看到我们自定义的NDI了\"></li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>如果你没有看到我们自定义的NDI，请检查你的模块是否被正确加载，最简单的办法就是在<code>PostInitProperties()</code>打个断点，看看程序是否运行进去了</li>\n</ul>\n<hr>\n<ul>\n<li><strong>来写一个CPU粒子用的NDI吧</strong>：<br>  <em>这一节中我希望我们的NDI能够在CPU粒子中被使用，并且打印一个LOG，LOG中打印一个数字</em><ol>\n<li>我们首先实现一个NDI的接口<code>CanExecuteOnTarget</code>，这个接口决定我们的NDI是否能被CPU&#x2F;GPU粒子使用。因为这里我们希望实现一个CPU粒子使用的NDI，因此，实现如下：  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">CanExecuteOnTarget</span><span class=\"params\">(ENiagaraSimTarget Target)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> Target == ENiagaraSimTarget::CPUSim; &#125;</span><br></pre></td></tr></table></figure></li>\n<li>然后我们给我们的NDI提供一个方法，我们每调用一次这个方法打印一条log。要实现这个目的，我们要实现两个接口<code>GetFunctions</code>、<code>GetVMExternalFunction</code></li>\n</ol>\n<ul>\n<li>GetFunctions：在这里告诉粒子系统，你的NDI能够给粒子系统提供什么方法、这些方法需要什么参数、有哪些输出；无论是CPU还是GPU粒子使用的方法都要在该接口的实现中声明；</li>\n<li>GetVMExternalFunction：在这里告诉粒子系统你在GetFunctions声明的CPU粒子用的方法，具体对应的函数是哪个<br>  具体的实现如下：  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctions</span><span class=\"params\">(TArray&lt;FNiagaraFunctionSignature&gt;&amp; OutFunctions)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">FNiagaraFunctionSignature Sig;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = PrintMyLogName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;PrintMyLogDescription&quot;</span>, <span class=\"string\">&quot;Print My Log.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tSig.bRequiresExecPin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetVMExternalFunction</span><span class=\"params\">(<span class=\"type\">const</span> FVMExternalFunctionBindingInfo&amp; BindingInfo, <span class=\"type\">void</span>* InstanceData, FVMExternalFunction&amp; OutFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (BindingInfo.Name == PrintMyLogName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOutFunc = FVMExternalFunction::<span class=\"built_in\">CreateLambda</span>([<span class=\"keyword\">this</span>](FVectorVMExternalFunctionContext&amp; Context) &#123; <span class=\"built_in\">UE_LOG</span>(LogNiagaraExt, Log, <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;Texwood0935 Debug My NDI: Print My Log!&quot;</span>)) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  编译重启项目，我们来看看效果  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%874.png\" class=\"\" title=\"调用我们的函数\">\n  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%875.png\" class=\"\" title=\"Log输出了^v^\"></li>\n<li>仔细观察，我们会发现节点分为可以直接执行的，和不直接执行的。他们的区别在于声明节点时<code>Sig.bRequiresExecPin</code>的值  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%876.png\" class=\"\" title=\"两种节点\"></li>\n</ul>\n<ol start=\"3\">\n<li>现在我想给我的NDI再加两个功能：设置一个变量的值以及输出一个变量<br>  参照第二点，我们通过<code>GetFunctions</code>、<code>GetVMExternalFunction</code>添加并且绑定两个节点  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctions</span><span class=\"params\">(TArray&lt;FNiagaraFunctionSignature&gt;&amp; OutFunctions)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">FNiagaraFunctionSignature Sig;</span><br><span class=\"line\">&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = SetMyNumName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;SetMyNumDescription&quot;</span>, <span class=\"string\">&quot;Set My Num.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tSig.bRequiresExecPin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(FNiagaraTypeDefinition::<span class=\"built_in\">GetFloatDef</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;InputNum&quot;</span>)));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = GetMyNumName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;GetMyNumDescription&quot;</span>, <span class=\"string\">&quot;Get My Num.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//Sig.bRequiresExecPin = true;</span></span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddOutput</span>(<span class=\"built_in\">FNiagaraVariable</span>(FNiagaraTypeDefinition::<span class=\"built_in\">GetFloatDef</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;MyNum&quot;</span>)), <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;OutputNumDescription&quot;</span>, <span class=\"string\">&quot;Returns MyNum&quot;</span>));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">DEFINE_NDI_DIRECT_FUNC_BINDER</span>(UMyNiagaraDataInterface, SetMyNumVM);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetVMExternalFunction</span><span class=\"params\">(<span class=\"type\">const</span> FVMExternalFunctionBindingInfo&amp; BindingInfo, <span class=\"type\">void</span>* InstanceData, FVMExternalFunction&amp; OutFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (BindingInfo.Name == PrintMyLogName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BindingInfo.Name == SetMyNumName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//除了Lambda函数、通过Lambda函数调用NDI的函数，我们还可以通过宏来绑定函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">NDI_FUNC_BINDER</span>(UMyNiagaraDataInterface, SetMyNumVM)::<span class=\"built_in\">Bind</span>(<span class=\"keyword\">this</span>, OutFunc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BindingInfo.Name == GetMyNumName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOutFunc = FVMExternalFunction::<span class=\"built_in\">CreateLambda</span>([<span class=\"keyword\">this</span>](FVectorVMExternalFunctionContext&amp; Context) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">GetMyNumVM</span>(Context);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  <code>SetMyNumVM</code>和<code>GetMyNumVM</code>就是我们具体的实现了，代码如下：  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::SetMyNumVM</span><span class=\"params\">(FVectorVMExternalFunctionContext&amp; Context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">FNDIInputParam&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">InMyNum</span><span class=\"params\">(Context)</span></span>;</span><br><span class=\"line\">MyNum = InMyNum.<span class=\"built_in\">GetAndAdvance</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetMyNumVM</span><span class=\"params\">(FVectorVMExternalFunctionContext&amp; Context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">FNDIOutputParam&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">OutMyNum</span><span class=\"params\">(Context)</span></span>;</span><br><span class=\"line\">OutMyNum.<span class=\"built_in\">SetAndAdvance</span>(MyNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  这里要注意一点：<strong>无论是FNDIInputParam还是FNDIOutputParam他们的模板填充进去的类型都只能是和float类型同样大小的类型，除非在引擎里事先定义好</strong>。这意味着并不是所有的类型都可以作为输入或者输出来给我们使用。<br>  编译重启项目，我们来看看效果  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%877.png\" class=\"\" title=\"调用我们的函数\">\n  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%878.png\" class=\"\" title=\"通过NiagaraDebugger我们可以看到MyNum被正确设置，并且输出\"></li>\n<li>不满足于此，我希望每个粒子都有属于它的”MyNum”<br>  每个粒子都要有属于它的”MyNum”，这意味着我们需要一个结构让每个粒子都储存一份MyNum的数据。使用一个结构体来储存：  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the struct used to store our data interface data</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FMyNiagaraDataInterfaceInstanceData</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">float</span> MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n  对于NDI我们需要干两件事：告诉NDI结构体的大小以及每个粒子都初始化一份结构体数据  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> int32 <span class=\"title\">PerInstanceDataSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">sizeof</span>(FMyNiagaraDataInterfaceInstanceData); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::InitPerInstanceData</span><span class=\"params\">(<span class=\"type\">void</span>* PerInstanceData, FNiagaraSystemInstance* SystemInstance)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">FMyNiagaraDataInterfaceInstanceData* InstanceData = <span class=\"built_in\">new</span> (PerInstanceData) FMyNiagaraDataInterfaceInstanceData;</span><br><span class=\"line\">InstanceData-&gt;MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  这里有一点要注意：<font color=\"#dd0000\">PerInstanceDataSize不为0的时候，每一个VMFunction开头一定要有<code>VectorVM::FUserPtrHandler&lt;FMyNiagaraDataInterfaceInstanceData&gt; InstData(Context)</code>，否则使用相应的方法时，会引发崩溃。</font><br>  编译重启项目，我们来看看效果  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%879.png\" class=\"\" title=\"调用我们的函数\">\n  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%8710.png\" class=\"\" title=\"每个粒子都了有属于它的MyNum\"></li>\n</ol>\n</li>\n</ul>\n","categories":["游戏知识笔记"],"tags":["UnrealEngine学习","Niagara相关"]}]