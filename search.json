[{"title":"Chaos物理学习笔记一：Chaos物理碰撞体结构","url":"/2023/07/01/Chaos%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","content":"<p>对于一个StaticMesh来说，它的物理相关的数据都存在它的BodySetup的成员变量中。<br>对于每个StaticMesh来说，碰撞分为简单碰撞和复杂碰撞。</p>\n<hr>\n<h3 id=\"简单碰撞\"><a href=\"#简单碰撞\" class=\"headerlink\" title=\"简单碰撞\"></a>简单碰撞</h3><p>简单碰撞相关的数据为UBodySetup的AggGeom成员变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UBodySetup</span> : <span class=\"keyword\">public</span> UBodySetupCore  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"comment\">/** Simplified collision representation of this  */</span>  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, Category = BodySetup, meta=(DisplayName = <span class=\"string\">&quot;Primitives&quot;</span>, NoResetToDefault))  </span><br><span class=\"line\">   <span class=\"keyword\">struct</span> <span class=\"title class_\">FKAggregateGeom</span> AggGeom;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">USTRUCT</span>()  </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ENGINE_API</span> FKAggregateGeom  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">   <span class=\"built_in\">GENERATED_USTRUCT_BODY</span>()  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, editfixedsize, Category = <span class=\"string\">&quot;Aggregate Geometry&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;Spheres&quot;</span>))  </span><br><span class=\"line\">   TArray&lt;FKSphereElem&gt; SphereElems;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, editfixedsize, Category = <span class=\"string\">&quot;Aggregate Geometry&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;Boxes&quot;</span>))  </span><br><span class=\"line\">   TArray&lt;FKBoxElem&gt; BoxElems;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, editfixedsize, Category = <span class=\"string\">&quot;Aggregate Geometry&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;Capsules&quot;</span>))  </span><br><span class=\"line\">   TArray&lt;FKSphylElem&gt; SphylElems;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, editfixedsize, Category = <span class=\"string\">&quot;Aggregate Geometry&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;Convex Elements&quot;</span>))  </span><br><span class=\"line\">   TArray&lt;FKConvexElem&gt; ConvexElems;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, editfixedsize, Category = <span class=\"string\">&quot;Aggregate Geometry&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;Tapered Capsules&quot;</span>))  </span><br><span class=\"line\">   TArray&lt;FKTaperedCapsuleElem&gt; TaperedCapsuleElems;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, editfixedsize, Category = <span class=\"string\">&quot;Aggregate Geometry&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;Level Sets&quot;</span>))  </span><br><span class=\"line\">   TArray&lt;FKLevelSetElem&gt; LevelSetElems;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码不难看出简单碰撞类型有很多，包括：盒状、球状、胶囊体、凸包等。并且一个模型可以由多个简单碰撞体组成。</p>\n<hr>\n<h3 id=\"复杂碰撞\"><a href=\"#复杂碰撞\" class=\"headerlink\" title=\"复杂碰撞\"></a>复杂碰撞</h3><ul>\n<li>复杂碰撞的数据在UBodySetup里面为成员变量ChaosTriMeshes。在Cook的时候会序列化一份ChaosTriMeshes数据，然后运行时通过CreatePhysicsMeshes这个函数从序列化的数据中构建ChaosTriMeshes。</li>\n<li>通常我们可以通过设置StaticMesh的Complex Collision Mesh来将别的模型设置为StaticMesh的用于复杂碰撞的模型(如果没有，则以LOD For Collision的LOD等级的原模型作为复杂碰撞的模型)</li>\n<li>观察StaticMesh的代码:<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UStaticMesh</span> : <span class=\"keyword\">public</span> UStreamableRenderAsset, <span class=\"keyword\">public</span> IInterface_CollisionDataProvider, <span class=\"keyword\">public</span> IInterface_AssetUserData, <span class=\"keyword\">public</span> IInterface_AsyncCompilation  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA  </span></span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(Instanced)  </span><br><span class=\"line\">   TObjectPtr&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">UObject</span>&gt; EditableMesh_DEPRECATED;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"built_in\">UPROPERTY</span>(EditAnywhere, Category = Collision)  </span><br><span class=\"line\">   TObjectPtr&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">UStaticMesh</span>&gt; ComplexCollisionMesh;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">ENGINE_API <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">CheckLightMapUVs</span><span class=\"params\">( UStaticMesh* InStaticMesh, TArray&lt; FString &gt;&amp; InOutAssetsWithMissingUVSets, TArray&lt; FString &gt;&amp; InOutAssetsWithBadUVSets, TArray&lt; FString &gt;&amp; InOutAssetsWithValidUVSets, <span class=\"type\">bool</span> bInVerbose = <span class=\"literal\">true</span> )</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"comment\">//~ Begin Interface_CollisionDataProvider Interface  </span></span><br><span class=\"line\">   <span class=\"function\">ENGINE_API <span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">GetPhysicsTriMeshData</span><span class=\"params\">(<span class=\"keyword\">struct</span> FTriMeshCollisionData* CollisionData, <span class=\"type\">bool</span> InUseAllTriData)</span> <span class=\"keyword\">override</span></span>;  </span><br><span class=\"line\">   <span class=\"function\">ENGINE_API <span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">ContainsPhysicsTriMeshData</span><span class=\"params\">(<span class=\"type\">bool</span> InUseAllTriData)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span></span>;  </span><br><span class=\"line\">   <span class=\"function\">ENGINE_API <span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">PollAsyncPhysicsTriMeshData</span><span class=\"params\">(<span class=\"type\">bool</span> InUseAllTriData)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span></span>;  </span><br><span class=\"line\">   <span class=\"function\">ENGINE_API <span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">GetTriMeshSizeEstimates</span><span class=\"params\">(<span class=\"keyword\">struct</span> FTriMeshCollisionDataEstimates&amp; OutTriMeshEstimates, <span class=\"type\">bool</span> bInUseAllTriData)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">GetPhysicsTriMeshDataCheckComplex</span><span class=\"params\">(<span class=\"keyword\">struct</span> FTriMeshCollisionData* CollisionData, <span class=\"type\">bool</span> bInUseAllTriData, <span class=\"type\">bool</span> bInCheckComplexCollisionMesh)</span></span>;  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ContainsPhysicsTriMeshDataCheckComplex</span><span class=\"params\">(<span class=\"type\">bool</span> InUseAllTriData, <span class=\"type\">bool</span> bInCheckComplexCollisionMesh)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  我们会发现ComplexCollisionMesh是一个只在编辑器下保存的数据。正如上文所说，复杂碰撞的数据会在Cook的时候被序列化下来。<br>  其中UBodySetup通过<code>GetPhysicsTriMeshData</code>来获取生成复杂碰撞需要的数据也就是<code>FTriMeshCollisionData* CollisionData</code>(通过这个数据我们也可以知道复杂碰撞准确的面数，当然这个数据仅限于编辑器下是准确的)</li>\n<li>另外，还有一个比较有意思的点，虚幻引擎无论是模型窗口还是关卡窗口，都有显示碰撞体的选项  <img data-src=\"/2023/07/01/Chaos%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/Chaos%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80_%E5%9B%BE%E7%89%871.png\" class=\"\" title=\"虚幻引擎无论是模型窗口还是关卡窗口，都有显示碰撞体的选项\">\n  但实际上会发现，如果设置了复杂碰撞(为了体现这一点，我还专门把模型的碰撞类型改为了 复杂碰撞用于简单)，这两个窗口的显示是不一样的  <img data-src=\"/2023/07/01/Chaos%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/Chaos%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80_%E5%9B%BE%E7%89%872.png\" class=\"\" title=\"两个窗口的显示是不一样的\">\n  那么到底哪个显示是正确的呢？答案是<strong>模型窗口下的显示是正确的</strong>。<br>  原因是关卡窗口下的显示通过ShowFlag让StaticMesh的动态绘制路径中提供碰撞相关的数据可视化要用的MeshBatch，然而在这里StaticMesh只是提供了自身lod的渲染数据当作复杂碰撞的数据。<br>  而在模型窗口下，”Complex Collision”按钮则比较正确的通过<code>GetPhysicsTriMeshData</code>获取生成复杂碰撞需要的数据，然后再通过DrawLine画出复杂碰撞的线框。</li>\n</ul>\n","categories":["技术学习","游戏知识笔记"],"tags":["UnrealEngine学习","Chaos物理相关"]},{"title":"NiagaraDataInterface笔记一：如何写一个NDI","url":"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/","content":"<h3 id=\"NDI简介：\"><a href=\"#NDI简介：\" class=\"headerlink\" title=\"NDI简介：\"></a>NDI简介：</h3><pre><code>Niagara是虚幻引擎推出的新的粒子系统\nNiagaraDataInterface就像Component之于Actor一样，能够通过用户自己的实现给Niagara提供许多功能\n</code></pre>\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%871.png\" class=\"\" title=\"UE自带很多NDI提供多种功能给粒子系统使用\">\n\n<h3 id=\"如何写一个NDI：\"><a href=\"#如何写一个NDI：\" class=\"headerlink\" title=\"如何写一个NDI：\"></a>如何写一个NDI：</h3><p>虽然有官方示例 ExampleCustomDataInterface的插件，但是有些函数的作用、以及一些注意点可能还是会有些不清楚。在此我使用一个更加简单的例子，来说明哪些函数的作用。</p>\n<p><strong>Let’s Start</strong></p>\n<h4 id=\"首先的准备：\"><a href=\"#首先的准备：\" class=\"headerlink\" title=\"首先的准备：\"></a>首先的准备：</h4><ol>\n<li>我们首先要在对应的模块的build.cs文件中引用<code>Niagara</code>、<code>NiagaraCore</code>两个模块 <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%872.png\" class=\"\" title=\"我们首先要在对应的模块的build.cs文件中引用&#96;Niagara&#96;、&#96;NiagaraCore&#96;两个模块\"></li>\n<li>然后对我们的NiagaraDataInterface，补充UCALSS里的声明，并且实现UObject的<code>PostInitProperties</code>接口 <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UCLASS</span>(EditInlineNew, Category = <span class=\"string\">&quot;MyNiagaraExt&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;My NDI&quot;</span>))</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NIAGARAEXT_API</span> UMyNiagaraDataInterface : <span class=\"keyword\">public</span> UNiagaraDataInterface</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"built_in\">GENERATED_BODY</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">//UObject Interface</span></span><br><span class=\"line\"><span class=\"comment\">//在这里注册NDI，以便在粒子编辑器中能看到我们的NDI</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">PostInitProperties</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//UObject Interface End</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::PostInitProperties</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Super::<span class=\"built_in\">PostInitProperties</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">HasAnyFlags</span>(RF_ClassDefaultObject))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tENiagaraTypeRegistryFlags Flags = ENiagaraTypeRegistryFlags::AllowAnyVariable | ENiagaraTypeRegistryFlags::AllowParameter;</span><br><span class=\"line\">\tFNiagaraTypeRegistry::<span class=\"built_in\">Register</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), Flags);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n编译打开项目，我们可以在粒子编辑器中看到我们自定义的NDI了 <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%873.png\" class=\"\" title=\"我们可以在粒子编辑器中看到我们自定义的NDI了\"></li>\n</ol>\n<ul>\n<li>如果你没有看到我们自定义的NDI，请检查你的模块是否被正确加载，最简单的办法就是在<code>PostInitProperties()</code>打个断点，看看程序是否运行进去了</li>\n</ul>\n<hr>\n<h4 id=\"来写一个CPU粒子用的NDI吧：\"><a href=\"#来写一个CPU粒子用的NDI吧：\" class=\"headerlink\" title=\"来写一个CPU粒子用的NDI吧：\"></a>来写一个CPU粒子用的NDI吧：</h4><p><em>这一节中我希望我们的NDI能够在CPU粒子中被使用，并且打印一个LOG，LOG中打印一个数字</em></p>\n<h5 id=\"首先告诉NDI它能够在CPU粒子上运行吧\"><a href=\"#首先告诉NDI它能够在CPU粒子上运行吧\" class=\"headerlink\" title=\"首先告诉NDI它能够在CPU粒子上运行吧\"></a>首先告诉NDI它能够在CPU粒子上运行吧</h5><p>我们需要实现一个NDI的接口<code>CanExecuteOnTarget</code>，这个接口决定我们的NDI是否能被CPU&#x2F;GPU粒子使用。<br>因为这里我们希望实现一个CPU粒子使用的NDI，因此，实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">CanExecuteOnTarget</span><span class=\"params\">(ENiagaraSimTarget Target)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> Target == ENiagaraSimTarget::CPUSim; &#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"打印一条log吧\"><a href=\"#打印一条log吧\" class=\"headerlink\" title=\"打印一条log吧\"></a>打印一条log吧</h5><p>现在我们给我们的NDI提供一个方法，我们每调用一次这个方法打印一条log。<br>要实现这个目的，我们要实现两个接口<code>GetFunctions</code>、<code>GetVMExternalFunction</code></p>\n<ul>\n<li>GetFunctions：在这里告诉粒子系统，你的NDI能够给粒子系统提供什么方法、这些方法需要什么参数、有哪些输出；无论是CPU还是GPU粒子使用的方法都要在该接口的实现中声明；</li>\n<li>GetVMExternalFunction：在这里告诉粒子系统你在GetFunctions声明的CPU粒子用的方法，具体对应的函数是哪个<br>具体的实现如下：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctions</span><span class=\"params\">(TArray&lt;FNiagaraFunctionSignature&gt;&amp; OutFunctions)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">FNiagaraFunctionSignature Sig;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = PrintMyLogName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;PrintMyLogDescription&quot;</span>, <span class=\"string\">&quot;Print My Log.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tSig.bRequiresExecPin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetVMExternalFunction</span><span class=\"params\">(<span class=\"type\">const</span> FVMExternalFunctionBindingInfo&amp; BindingInfo, <span class=\"type\">void</span>* InstanceData, FVMExternalFunction&amp; OutFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (BindingInfo.Name == PrintMyLogName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOutFunc = FVMExternalFunction::<span class=\"built_in\">CreateLambda</span>([<span class=\"keyword\">this</span>](FVectorVMExternalFunctionContext&amp; Context) &#123; <span class=\"built_in\">UE_LOG</span>(LogNiagaraExt, Log, <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;Texwood0935 Debug My NDI: Print My Log!&quot;</span>)) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p> 编译重启项目，我们来看看效果<br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%874.png\" class=\"\" title=\"调用我们的函数\"><br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%875.png\" class=\"\" title=\"Log输出了^v^\"></p>\n<ul>\n<li>仔细观察，我们会发现节点分为可以直接执行的，和不直接执行的。他们的区别在于声明节点时<code>Sig.bRequiresExecPin</code>的值  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%876.png\" class=\"\" title=\"两种节点\"></li>\n</ul>\n<hr>\n<h5 id=\"再加两个功能\"><a href=\"#再加两个功能\" class=\"headerlink\" title=\"再加两个功能\"></a>再加两个功能</h5><p>现在我想给我的NDI再加两个功能：设置一个变量的值以及输出一个变量<br>参照第二点，我们通过<code>GetFunctions</code>、<code>GetVMExternalFunction</code>添加并且绑定两个节点</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctions</span><span class=\"params\">(TArray&lt;FNiagaraFunctionSignature&gt;&amp; OutFunctions)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">FNiagaraFunctionSignature Sig;</span><br><span class=\"line\">&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = SetMyNumName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;SetMyNumDescription&quot;</span>, <span class=\"string\">&quot;Set My Num.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tSig.bRequiresExecPin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(FNiagaraTypeDefinition::<span class=\"built_in\">GetFloatDef</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;InputNum&quot;</span>)));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = GetMyNumName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;GetMyNumDescription&quot;</span>, <span class=\"string\">&quot;Get My Num.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//Sig.bRequiresExecPin = true;</span></span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddOutput</span>(<span class=\"built_in\">FNiagaraVariable</span>(FNiagaraTypeDefinition::<span class=\"built_in\">GetFloatDef</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;MyNum&quot;</span>)), <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;OutputNumDescription&quot;</span>, <span class=\"string\">&quot;Returns MyNum&quot;</span>));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">DEFINE_NDI_DIRECT_FUNC_BINDER</span>(UMyNiagaraDataInterface, SetMyNumVM);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetVMExternalFunction</span><span class=\"params\">(<span class=\"type\">const</span> FVMExternalFunctionBindingInfo&amp; BindingInfo, <span class=\"type\">void</span>* InstanceData, FVMExternalFunction&amp; OutFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (BindingInfo.Name == PrintMyLogName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BindingInfo.Name == SetMyNumName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//除了Lambda函数、通过Lambda函数调用NDI的函数，我们还可以通过宏来绑定函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">NDI_FUNC_BINDER</span>(UMyNiagaraDataInterface, SetMyNumVM)::<span class=\"built_in\">Bind</span>(<span class=\"keyword\">this</span>, OutFunc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BindingInfo.Name == GetMyNumName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOutFunc = FVMExternalFunction::<span class=\"built_in\">CreateLambda</span>([<span class=\"keyword\">this</span>](FVectorVMExternalFunctionContext&amp; Context) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">GetMyNumVM</span>(Context);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SetMyNumVM</code>和<code>GetMyNumVM</code>就是我们具体的实现了，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::SetMyNumVM</span><span class=\"params\">(FVectorVMExternalFunctionContext&amp; Context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">FNDIInputParam&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">InMyNum</span><span class=\"params\">(Context)</span></span>;</span><br><span class=\"line\">MyNum = InMyNum.<span class=\"built_in\">GetAndAdvance</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetMyNumVM</span><span class=\"params\">(FVectorVMExternalFunctionContext&amp; Context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">FNDIOutputParam&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">OutMyNum</span><span class=\"params\">(Context)</span></span>;</span><br><span class=\"line\">OutMyNum.<span class=\"built_in\">SetAndAdvance</span>(MyNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里要注意一点：<strong>无论是FNDIInputParam还是FNDIOutputParam他们的模板填充进去的类型都只能是和float类型同样大小的类型，除非在引擎里事先定义好</strong>。这意味着并不是所有的类型都可以作为输入或者输出来给我们使用。</p>\n<p>编译重启项目，我们来看看效果</p>\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%877.png\" class=\"\" title=\"调用我们的函数\">\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%878.png\" class=\"\" title=\"通过NiagaraDebugger我们可以看到MyNum被正确设置，并且输出\">\n\n<hr>\n<h5 id=\"不满足于此，我希望每个粒子都有属于它的”MyNum”\"><a href=\"#不满足于此，我希望每个粒子都有属于它的”MyNum”\" class=\"headerlink\" title=\"不满足于此，我希望每个粒子都有属于它的”MyNum”\"></a>不满足于此，我希望每个粒子都有属于它的”MyNum”</h5><p>每个粒子都要有属于它的”MyNum”，这意味着我们需要一个结构让每个粒子都储存一份MyNum的数据。使用一个结构体来储存：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the struct used to store our data interface data</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FMyNiagaraDataInterfaceInstanceData</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">float</span> MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于NDI我们需要干几件事：告诉NDI结构体的大小以及每个粒子都初始化一份结构体数据还有在每个粒子销毁的时候释放我们的结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> int32 <span class=\"title\">PerInstanceDataSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">sizeof</span>(FMyNiagaraDataInterfaceInstanceData); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::InitPerInstanceData</span><span class=\"params\">(<span class=\"type\">void</span>* PerInstanceData, FNiagaraSystemInstance* SystemInstance)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">\tFMyNiagaraDataInterfaceInstanceData* InstanceData = <span class=\"built_in\">new</span> (PerInstanceData) FMyNiagaraDataInterfaceInstanceData;</span><br><span class=\"line\">\tInstanceData-&gt;MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::DestroyPerInstanceData</span><span class=\"params\">(<span class=\"type\">void</span>* PerInstanceData, FNiagaraSystemInstance* SystemInstance)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFMyNiagaraDataInterfaceInstanceData* InstData = <span class=\"built_in\">static_cast</span>&lt;FMyNiagaraDataInterfaceInstanceData*&gt;(PerInstanceData);</span><br><span class=\"line\">\tInstData-&gt;~<span class=\"built_in\">FMyNiagaraDataInterfaceInstanceData</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一点要注意：<font color=\"#dd0000\">PerInstanceDataSize不为0的时候，每一个VMFunction开头一定要有<code>VectorVM::FUserPtrHandler&lt;FMyNiagaraDataInterfaceInstanceData&gt; InstData(Context)</code>，否则使用相应的方法时，会引发崩溃。</font></p>\n<p>编译重启项目，我们来看看效果<br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%879.png\" class=\"\" title=\"调用我们的函数\"><br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%8710.png\" class=\"\" title=\"每个粒子都了有属于它的MyNum\"></p>\n<hr>\n<h5 id=\"其他一些\"><a href=\"#其他一些\" class=\"headerlink\" title=\"其他一些\"></a>其他一些</h5><p>除了上面提到的一些接口，还有些比较重要的接口：</p>\n<ul>\n<li>PerInstanceTick：每个粒子的Tick。</li>\n<li>PerInstanceTickPostSimulate：与上面的Tick不同之处在于Tick的阶段、时机不同</li>\n<li>Equals：判断两个NDI是否相等</li>\n<li>CopyToInternal：将一个NDI的数据拷贝到另一个<br>上述都是一些比较重要的接口。其中，如果没有实现<code>Equals</code>、<code>CopyToInternal</code>可能会导致NDI拷贝的时候，有参数没有被正确拷贝。作者就遇到过没实现这两个接口，导致在粒子的scratch module传参错误的情况</li>\n</ul>\n<hr>\n<h4 id=\"来实现一个GPU粒子用的NDI：\"><a href=\"#来实现一个GPU粒子用的NDI：\" class=\"headerlink\" title=\"来实现一个GPU粒子用的NDI：\"></a>来实现一个GPU粒子用的NDI：</h4><p><em>这一节中我希望我们的NDI能够在GPU粒子中获取到MyNum的值</em></p>\n<h5 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h5><p>和CPU粒子的第一步相同，我们先让NDI能够在GPU粒子上运行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">CanExecuteOnTarget</span><span class=\"params\">(ENiagaraSimTarget Target)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> Target == ENiagaraSimTarget::CPUSim || Target == ENiagaraSimTarget::GPUComputeSim; &#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外GPU粒子还需要额外写Shader，因此我们还需要模块里对shader路径进行映射</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">FNiagaraExtModule::StartupModule</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// map the shader dir so we can use it in the data interface</span></span><br><span class=\"line\">\tFString NiagaraExtShaderDir = FPaths::<span class=\"built_in\">Combine</span>(FPaths::<span class=\"built_in\">GameSourceDir</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;NiagaraExt/Shaders&quot;</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">AddShaderSourceDirectoryMapping</span>(<span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;/NiagaraExt&quot;</span>), NiagaraExtShaderDir);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"第二步：绑定shader以及相关的hlsl函数\"><a href=\"#第二步：绑定shader以及相关的hlsl函数\" class=\"headerlink\" title=\"第二步：绑定shader以及相关的hlsl函数\"></a>第二步：绑定shader以及相关的hlsl函数</h5><p>正如一般的shader声明流程，我们首先在类里用宏声明shader参数的结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NIAGARAEXT_API</span> UMyNiagaraDataInterface : <span class=\"keyword\">public</span> UNiagaraDataInterface</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">GENERATED_BODY</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">BEGIN_SHADER_PARAMETER_STRUCT</span>(FShaderParameters, )</span><br><span class=\"line\">\t\t<span class=\"built_in\">SHADER_PARAMETER</span>(<span class=\"type\">float</span>, MyNum)</span><br><span class=\"line\">\t<span class=\"built_in\">END_SHADER_PARAMETER_STRUCT</span>()</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们实现两个绑定shader参数的接口</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::BuildShaderParameters</span><span class=\"params\">(FNiagaraShaderParametersBuilder&amp; ShaderParametersBuilder)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tShaderParametersBuilder.<span class=\"built_in\">AddNestedStruct</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::SetShaderParameters</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceSetShaderParametersContext&amp; Context)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFShaderParameters* ShaderParameters = Context.<span class=\"built_in\">GetParameterNestedStruct</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">\tShaderParameters-&gt;MyNum = MyNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再是一些有关shader编译、hlsl函数参数相关的接口</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::AppendCompileHash</span><span class=\"params\">(FNiagaraCompileHashVisitor* InVisitor)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!Super::<span class=\"built_in\">AppendCompileHash</span>(InVisitor))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tInVisitor-&gt;<span class=\"built_in\">UpdateShaderFile</span>(MyNiagaraDataInterfaceShaderFile);</span><br><span class=\"line\">\tInVisitor-&gt;<span class=\"built_in\">UpdateShaderParameters</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctionHLSL</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceGPUParamInfo&amp; ParamInfo, <span class=\"type\">const</span> FNiagaraDataInterfaceGeneratedFunction&amp; FunctionInfo, <span class=\"type\">int</span> FunctionInstanceIndex, FString&amp; OutHLSL)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FunctionInfo.DefinitionName == GetMyNumName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetParameterDefinitionHLSL</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceGPUParamInfo&amp; ParamInfo, FString&amp; OutHLSL)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> TMap&lt;FString, FStringFormatArg&gt; TemplateArgs =</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;ParameterName&quot;</span>),\tParamInfo.DataInterfaceHLSLSymbol&#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">AppendTemplateHLSL</span>(OutHLSL, MyNiagaraDataInterfaceShaderFile, TemplateArgs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，shader中我们提供给NDI的函数以及NDI传进来的参数都需要被<code>&#123;ParameterName&#125;</code>修饰，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// when using a template ush file, we need the _&#123;ParameterName&#125; appendix on global functions and parameters, because the template can be included multiple times for different data interfaces in a system.</span></span><br><span class=\"line\"><span class=\"type\">float</span> &#123;ParameterName&#125;_MyNum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> GetMyNum_&#123;ParameterName&#125;(out <span class=\"type\">float</span> Out_MyNum)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOut_MyNum = &#123;ParameterName&#125;_MyNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，和PrimitiveComponent一样，NDI也需要一个Proxy<br>对于支持GPU粒子的NDI来说，还需要一个实现了FNiagaraDataInterfaceProxy的类以及在构造函数里为Proxy设置值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FMyNiagaraDataInterfaceProxy</span> : <span class=\"keyword\">public</span> FNiagaraDataInterfaceProxy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> int32 <span class=\"title\">PerInstanceDataPassedToRenderThreadSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">...</span><br><span class=\"line\">UMyNiagaraDataInterface::<span class=\"built_in\">UMyNiagaraDataInterface</span>(FObjectInitializer <span class=\"type\">const</span>&amp; ObjectInitializer)</span><br><span class=\"line\">\t: <span class=\"built_in\">Super</span>(ObjectInitializer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tProxy.<span class=\"built_in\">Reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">FMyNiagaraDataInterfaceProxy</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成了以上步骤会发现，虽然GPU粒子能够获得MyNum的值，但是只能获得默认值。也就是如果我改变了MyNum的值，GPU粒子获取的值并没有改变。<br>这是因为两点：</p>\n<ol>\n<li>SetShaderParameters里面不要使用原生的NDI的值，要用Proxy里面的值，因为这在RenderThread中</li>\n<li>CopyToInternal没有正确实现<br>更正完错误后，我们的代码为：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FMyNiagaraDataInterfaceProxy</span> : <span class=\"keyword\">public</span> FNiagaraDataInterfaceProxy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> int32 <span class=\"title\">PerInstanceDataPassedToRenderThreadSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">float</span> MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">FMyNiagaraDataInterfaceProxy</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">FMyNiagaraDataInterfaceProxy</span>(<span class=\"type\">float</span> InMyNum) : <span class=\"built_in\">MyNum</span>(InMyNum) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UpdateMyNum</span><span class=\"params\">(<span class=\"type\">float</span> InMyNum)</span> </span>&#123; MyNum = InMyNum; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::CopyToInternal</span><span class=\"params\">(UNiagaraDataInterface* Destination)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!Super::<span class=\"built_in\">CopyToInternal</span>(Destination))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUMyNiagaraDataInterface* OtherTyped = <span class=\"built_in\">CastChecked</span>&lt;UMyNiagaraDataInterface&gt;(Destination);</span><br><span class=\"line\">\tOtherTyped-&gt;MyNum = MyNum;</span><br><span class=\"line\"></span><br><span class=\"line\">\tOtherTyped-&gt;<span class=\"built_in\">GetProxyAs</span>&lt;FMyNiagaraDataInterfaceProxy&gt;()-&gt;<span class=\"built_in\">UpdateMyNum</span>(MyNum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::SetShaderParameters</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceSetShaderParametersContext&amp; Context)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFMyNiagaraDataInterfaceProxy&amp; DataInterfaceProxy = Context.<span class=\"built_in\">GetProxy</span>&lt;FMyNiagaraDataInterfaceProxy&gt;();</span><br><span class=\"line\">\tFShaderParameters* ShaderParameters = Context.<span class=\"built_in\">GetParameterNestedStruct</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">\tShaderParameters-&gt;MyNum = DataInterfaceProxy.MyNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>编译重启项目，我们来看看效果</p>\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%8711.png\" class=\"\" title=\"GPU粒子获取到正确的值了\">\n\n<hr>\n<h3 id=\"最后的其他\"><a href=\"#最后的其他\" class=\"headerlink\" title=\"最后的其他\"></a>最后的其他</h3><p>其实上面还有很多点没提到，比如：虚幻很多东西设置参数都是通过名称来设置，但是我们的节点没法塞字符串类型的输入进去，这个时候该怎么做之类的。<br>官方有很多NDI，去参考官方NDI的实现很多疑问也会被解决，以后有空也会写些有关于官方NDI源码分析的笔记。</p>\n","categories":["技术学习","游戏知识笔记"],"tags":["UnrealEngine学习","Niagara相关"]},{"title":"虚幻引擎如何添加一个MeshPass","url":"/2023/07/01/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAMeshPass/","content":"<p>这一章中，我希望通过添加一个MeshPass的形式把标记了特定Tag的物体渲染成一张特定的RT作为蒙版。虽然CustomDepth之类的功能也能方便地做到这一点，但这里主要是想通过这个来学习如何添加一个MeshPass</p>\n","categories":["技术学习","游戏知识笔记"],"tags":["UnrealEngine学习","渲染相关"]},{"title":"虚幻引擎渲染机制学习笔记","url":"/2023/07/01/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<p><a href=\"https://www.cnblogs.com/timlly/p/14588598.html\">向往大佬有关虚幻渲染机制的博客</a></p>\n<ol>\n<li><p>虚幻引擎分为GameThread和RenderThread，UPrimitiveComponent是可渲染物体在GameThread的数据，UPrimitiveSceneProxy是可渲染物体在RenderThread的数据<br> (为什么分为两个，个人认为是为了避免线程之间数据读写带来的一系列问题)</p>\n</li>\n<li><p>有关于类似模型之类的渲染对象的渲染数据用FMeshBatchElement表示，FMeshBatch则是一系列FMeshBatchElement的数据。这两者都是RenderThread中的对象</p>\n</li>\n<li><p>对于可渲染的对象UPrimitiveComponent，分为静态绘制路径和动态绘制路径，可以理解为：像StaticMesh这种不会每帧改变的物体，一般使用静态绘制路径，如果是类似某些水体之类的每帧都要改变的物体则需要动态绘制路径</p>\n</li>\n<li><p><code>DrawStaticElements</code>：以地形渲染为例<br> 地形渲染的图元组件分别为：ULandscapeComponent和FLandscapeComponentSceneProxy<br> 地形是我们导入或者使用UE的地形编辑工具生成的一个Mesh，地形渲染基本上走的是静态绘制路径。<br> 对于静态绘制路径中UPrimitiveSceneProxy来说，最重要的是<code>virtual void DrawStaticElements(FStaticPrimitiveDrawInterface* PDI)</code>这个接口。<br> 在这个接口中，我们把各级LOD代表的Mesh加到PDI中，并且还要告诉PDI当模型的包围盒在屏幕中的占比为多少时，选择哪级LOD。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">FLandscapeComponentSceneProxy::DrawStaticElements</span><span class=\"params\">(FStaticPrimitiveDrawInterface* PDI)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">  ... </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (int32 LODIndex = FirstLOD; LODIndex &lt;= LastLOD; LODIndex++)  </span><br><span class=\"line\">  &#123;      FMeshBatch MeshBatch;  </span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"built_in\">GetStaticMeshElement</span>(LODIndex, <span class=\"literal\">false</span>, MeshBatch, StaticBatchParamArray))  </span><br><span class=\"line\">     &#123;         PDI-&gt;<span class=\"built_in\">DrawMesh</span>(MeshBatch, LODIndex == FirstLOD ? FLT_MAX : (FMath::<span class=\"built_in\">Sqrt</span>(LODScreenRatioSquared[LODIndex]) * <span class=\"number\">2.0f</span>));  </span><br><span class=\"line\">     &#125;   &#125;  </span><br><span class=\"line\">  <span class=\"built_in\">check</span>(StaticBatchParamArray.<span class=\"built_in\">Num</span>() &lt;= TotalBatchCount);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在FLandscapeComponentSceneProxy我们可以看到，地形首先会事先构建好各级LOD对应的包围盒屏占比，然后再<code>DrawStaticElements</code>中先构建MeshBatch然后再通过DrawMesh把各级LOD渲染需要的信息告诉PDI</p>\n</li>\n<li><p><code>GetDynamicMeshElements</code>：接口的样式为<br> <code>virtual void GetDynamicMeshElements(const TArray&lt;const FSceneView*&gt;&amp; Views, const FSceneViewFamily&amp; ViewFamily, uint32 VisibilityMap, FMeshElementCollector&amp; Collector) const</code><br> 和<code>DrawStaticElements</code>一样本质上是要把MeshBatch加到Collector中，这里以ShowCollision时，简单碰撞的凸包的绘制为例：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(bDrawSolid)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">   <span class=\"comment\">// Cache collision vertex/index buffer  </span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(!RenderInfo)  </span><br><span class=\"line\">   &#123;      <span class=\"comment\">//这里要自己构建顶点数据以及索引，然后把这些数据组建成MeshBatch提供信息给Collector</span></span><br><span class=\"line\">      FKAggregateGeom&amp; ThisGeom = <span class=\"built_in\">const_cast</span>&lt;FKAggregateGeom&amp;&gt;(*<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">      ThisGeom.RenderInfo = <span class=\"keyword\">new</span> <span class=\"built_in\">FKConvexGeomRenderInfo</span>();  </span><br><span class=\"line\">      ThisGeom.RenderInfo-&gt;VertexBuffers = <span class=\"keyword\">new</span> <span class=\"built_in\">FStaticMeshVertexBuffers</span>();  </span><br><span class=\"line\">      ThisGeom.RenderInfo-&gt;IndexBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">FDynamicMeshIndexBuffer32</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\">      TArray&lt;FDynamicMeshVertex&gt; OutVerts;  </span><br><span class=\"line\">      <span class=\"keyword\">for</span>(int32 i=<span class=\"number\">0</span>; i&lt;ConvexElems.<span class=\"built_in\">Num</span>(); i++)  </span><br><span class=\"line\">      &#123;         <span class=\"comment\">// Get vertices/triangles from this hull. </span></span><br><span class=\"line\">\t\t\t    <span class=\"comment\">//构建IndexBuffer </span></span><br><span class=\"line\">         ConvexElems[i].<span class=\"built_in\">AddCachedSolidConvexGeom</span>(OutVerts, ThisGeom.RenderInfo-&gt;IndexBuffer-&gt;Indices, FColor::White);  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      <span class=\"comment\">// Only continue if we actually got some valid geometry  </span></span><br><span class=\"line\">      <span class=\"comment\">// Will crash if we try to init buffers with no data      if(ThisGeom.RenderInfo-&gt;VertexBuffers  </span></span><br><span class=\"line\">         &amp;&amp; ThisGeom.RenderInfo-&gt;IndexBuffer  </span><br><span class=\"line\">         &amp;&amp; OutVerts.<span class=\"built_in\">Num</span>() &gt; <span class=\"number\">0</span>  </span><br><span class=\"line\">         &amp;&amp; ThisGeom.RenderInfo-&gt;IndexBuffer-&gt;Indices.<span class=\"built_in\">Num</span>() &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">      &#123;         ThisGeom.RenderInfo-&gt;IndexBuffer-&gt;<span class=\"built_in\">InitResource</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\">         ThisGeom.RenderInfo-&gt;CollisionVertexFactory = <span class=\"keyword\">new</span> <span class=\"built_in\">FLocalVertexFactory</span>(Collector.<span class=\"built_in\">GetFeatureLevel</span>(), <span class=\"string\">&quot;FKAggregateGeom&quot;</span>);  </span><br><span class=\"line\">         <span class=\"comment\">//把顶点数据告诉CollisionVertexFactory</span></span><br><span class=\"line\">         ThisGeom.RenderInfo-&gt;VertexBuffers-&gt;<span class=\"built_in\">InitFromDynamicVertex</span>(ThisGeom.RenderInfo-&gt;CollisionVertexFactory, OutVerts);  </span><br><span class=\"line\">  </span><br><span class=\"line\">      &#125;   &#125;  </span><br><span class=\"line\">   <span class=\"comment\">// If we have geometry to draw, do so  </span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(RenderInfo-&gt;<span class=\"built_in\">HasValidGeometry</span>())  </span><br><span class=\"line\">   &#123;      <span class=\"comment\">// Calculate transform  </span></span><br><span class=\"line\">      FTransform LocalToWorld = <span class=\"built_in\">FTransform</span>(FQuat::Identity, FVector::ZeroVector, Scale3D) * ParentTM;  </span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"comment\">// Draw the mesh.  </span></span><br><span class=\"line\">      FMeshBatch&amp; Mesh = Collector.<span class=\"built_in\">AllocateMesh</span>();  </span><br><span class=\"line\">      FMeshBatchElement&amp; BatchElement = Mesh.Elements[<span class=\"number\">0</span>];  </span><br><span class=\"line\">      BatchElement.IndexBuffer = RenderInfo-&gt;IndexBuffer;  </span><br><span class=\"line\">      Mesh.VertexFactory = RenderInfo-&gt;CollisionVertexFactory;  </span><br><span class=\"line\">      Mesh.MaterialRenderProxy = MatInst;  </span><br><span class=\"line\">      FBoxSphereBounds WorldBounds, LocalBounds;  </span><br><span class=\"line\">      <span class=\"built_in\">CalcBoxSphereBounds</span>(WorldBounds, LocalToWorld);  </span><br><span class=\"line\">      <span class=\"built_in\">CalcBoxSphereBounds</span>(LocalBounds, FTransform::Identity);  </span><br><span class=\"line\">  </span><br><span class=\"line\">      FDynamicPrimitiveUniformBuffer&amp; DynamicPrimitiveUniformBuffer = Collector.<span class=\"built_in\">AllocateOneFrameResource</span>&lt;FDynamicPrimitiveUniformBuffer&gt;();  </span><br><span class=\"line\">      DynamicPrimitiveUniformBuffer.<span class=\"built_in\">Set</span>(LocalToWorld.<span class=\"built_in\">ToMatrixWithScale</span>(), LocalToWorld.<span class=\"built_in\">ToMatrixWithScale</span>(), WorldBounds, LocalBounds, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, bOutputVelocity);  </span><br><span class=\"line\">      BatchElement.PrimitiveUniformBufferResource = &amp;DynamicPrimitiveUniformBuffer.UniformBuffer;  </span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"comment\">// previous l2w not used so treat as static  </span></span><br><span class=\"line\">      BatchElement.FirstIndex = <span class=\"number\">0</span>;  </span><br><span class=\"line\">      BatchElement.NumPrimitives = RenderInfo-&gt;IndexBuffer-&gt;Indices.<span class=\"built_in\">Num</span>() / <span class=\"number\">3</span>;  </span><br><span class=\"line\">      BatchElement.MinVertexIndex = <span class=\"number\">0</span>;  </span><br><span class=\"line\">      BatchElement.MaxVertexIndex = RenderInfo-&gt;VertexBuffers-&gt;PositionVertexBuffer.<span class=\"built_in\">GetNumVertices</span>() - <span class=\"number\">1</span>;  </span><br><span class=\"line\">      Mesh.ReverseCulling = LocalToWorld.<span class=\"built_in\">GetDeterminant</span>() &lt; <span class=\"number\">0.0f</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;  </span><br><span class=\"line\">      Mesh.Type = PT_TriangleList;  </span><br><span class=\"line\">      Mesh.DepthPriorityGroup = SDPG_World;  </span><br><span class=\"line\">      Mesh.bCanApplyViewModeOverrides = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">      Collector.<span class=\"built_in\">AddMesh</span>(ViewIndex, Mesh);  </span><br><span class=\"line\">   &#125;&#125;  </span><br><span class=\"line\"><span class=\"keyword\">else</span>  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t<span class=\"comment\">//这里是简单地通过DrawLine画出一个个三角形的线框模式</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(int32 i=<span class=\"number\">0</span>; i&lt;ConvexElems.<span class=\"built_in\">Num</span>(); i++)  </span><br><span class=\"line\">   &#123;      FColor ConvexColor = bPerHullColor ? DebugUtilColor[i%NUM_DEBUG_UTIL_COLORS] : Color;  </span><br><span class=\"line\">      FTransform ElemTM = ConvexElems[i].<span class=\"built_in\">GetTransform</span>();  </span><br><span class=\"line\">      ElemTM *= Transform;  </span><br><span class=\"line\">      ConvexElems[i].<span class=\"built_in\">DrawElemWire</span>(Collector.<span class=\"built_in\">GetPDI</span>(ViewIndex), ElemTM, <span class=\"number\">1.f</span>, ConvexColor);    <span class=\"comment\">//we pass in 1 for scale because the ElemTM already has the scale baked into it  </span></span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 参考这一段将凸包数据画出来的代码，分为两种情况：一种是简单地通过DrawLine画出一个个三角形的线框模式；还有一种是要自己构建顶点数据以及索引，然后把这些数据组建成MeshBatch提供信息给<code>Collector</code>。<br> 其中顶点相关的数据是存在VertexFactory中，而索引的Buffer需要自己另外构建<br> 这里要注意的一点是，由于<em>碰撞数据在模型中不同于渲染数据，因此我要画这些东西，可能需要自己构造相应的IndexBuffer和VertexBuffer告诉MeshBatch顶点和索引的信息</em>。</p>\n</li>\n<li><p>除上述两个接口之外还有一个很重要的接口<code>virtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View) const</code>这个接口会决定你的Mesh是否会加入某个Pass的绘制(举例就是我在仿照UE源码添加一个MeshPass的时候，忽略了这个接口导致最终结果错误orz)</p>\n</li>\n<li><p>综上，<strong>对于研究一个图元组件渲染相关的一些参数，可以通过研究它的MeshBatch结构入手</strong></p>\n</li>\n<li><p>有些时候，可能希望通过一些指令动态改变渲染的一些参数，如果是动态绘制路径还好，毕竟每帧都会调用，但是因为静态绘制路径是事先缓存好的，因此直接改变可能会不起作用，需要调用对应的UPrimitiveComponent的<code>MarkRenderStateDirty()</code>接口才能触发静态绘制路径的MeshBatch重新加入PDI</p>\n</li>\n</ol>\n<hr>\n","categories":["技术学习","游戏知识笔记"],"tags":["UnrealEngine学习","渲染相关"]},{"title":"虚幻引擎MemReport工具使用笔记","url":"/2023/07/06/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8EMemreport%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","content":"<ul>\n<li>虚幻引擎可以用指令<code>MemReport -full</code>来输出一份内存报告。生成的内存报告路径一般在：&#96;Project\\Saved\\Profiling\\MemReports\\ 下。</li>\n<li>这份报告里我们可以看到虚幻引擎各种资源在内存里的大小，以及部分资源信息，例如：贴图大小、贴图格式等。</li>\n<li>对于很多资源我们可以看到这样的格式：  <img data-src=\"/2023/07/06/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8EMemreport%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/MemReport%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0_%E5%9B%BE%E7%89%871.png\" class=\"\">\n  在代码里面，这些数据是这样输出的：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (bCSV)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">   Ar.<span class=\"built_in\">Logf</span>(<span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;,Object,NumKB,MaxKB,ResExcKB,ResExcDedSysKB,ResExcDedVidKB,ResExcUnkKB&quot;</span>));  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">else</span>  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">   Ar.<span class=\"built_in\">Logf</span>(  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;%140s %10s %10s %10s %15s %15s %15s&quot;</span>),  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;Object&quot;</span>),  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;NumKB&quot;</span>),  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;MaxKB&quot;</span>),  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;ResExcKB&quot;</span>),  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;ResExcDedSysKB&quot;</span>),  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;ResExcDedVidKB&quot;</span>),  </span><br><span class=\"line\">      <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;ResExcUnkKB&quot;</span>)  </span><br><span class=\"line\">   );&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> FSubItem&amp; ObjItem : Objects)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">if</span> (bCSV)  </span><br><span class=\"line\">   &#123;      Ar.<span class=\"built_in\">Logf</span>(  </span><br><span class=\"line\">         <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;,%s,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f&quot;</span>),  </span><br><span class=\"line\">         *ObjItem.Object-&gt;<span class=\"built_in\">GetFullName</span>(),  </span><br><span class=\"line\">         ObjItem.Num / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.Max / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetTotalMemoryBytes</span>() / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetDedicatedSystemMemoryBytes</span>() / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetDedicatedVideoMemoryBytes</span>() / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetUnknownMemoryBytes</span>() / <span class=\"number\">1024.0f</span>  </span><br><span class=\"line\">      );  </span><br><span class=\"line\">  </span><br><span class=\"line\">   &#125;   <span class=\"keyword\">else</span>  </span><br><span class=\"line\">   &#123;  </span><br><span class=\"line\">      Ar.<span class=\"built_in\">Logf</span>(  </span><br><span class=\"line\">         <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;%140s %10.2f %10.2f %10.2f %15.2f %15.2f %15.2f&quot;</span>),  </span><br><span class=\"line\">         *ObjItem.Object-&gt;<span class=\"built_in\">GetFullName</span>(),  </span><br><span class=\"line\">         ObjItem.Num / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.Max / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetTotalMemoryBytes</span>() / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetDedicatedSystemMemoryBytes</span>() / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetDedicatedVideoMemoryBytes</span>() / <span class=\"number\">1024.0f</span>,  </span><br><span class=\"line\">         ObjItem.TrueResourceSize.<span class=\"built_in\">GetUnknownMemoryBytes</span>() / <span class=\"number\">1024.0f</span>  </span><br><span class=\"line\">      );  </span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bVerboseObjectOutput)  </span><br><span class=\"line\">      &#123;         ObjItem.TrueResourceSize.<span class=\"built_in\">LogSummary</span>(Ar);  </span><br><span class=\"line\">      &#125;   &#125;&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n  从代码里面不难看出后四列的含义：<strong>总内存占用、专用系统内存占用、专用显存占用、未知的内存占用</strong>。但是前两列的含义就不清晰了。<br>  继续追踪代码，实际上<code>ObjItem</code>关于NumKB和MaxKB的内存信息是由类<code>FArchiveCountMem</code>收集的。观察<code>FArchiveCountMem</code>的实现：  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">FArchiveCountMem</span> : <span class=\"keyword\">public</span> FArchiveUObject  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">   <span class=\"built_in\">FArchiveCountMem</span>( UObject* Src, <span class=\"type\">bool</span> bFilterEditorOnly = <span class=\"literal\">false</span> )  </span><br><span class=\"line\">      : <span class=\"built_in\">Num</span>(<span class=\"number\">0</span>)  </span><br><span class=\"line\">      , <span class=\"built_in\">Max</span>(<span class=\"number\">0</span>)  </span><br><span class=\"line\">   &#123;      ArIsCountingMemory = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">      ArIsFilterEditorOnly = bFilterEditorOnly;  </span><br><span class=\"line\">      <span class=\"keyword\">if</span>( Src )  </span><br><span class=\"line\">      &#123;         Src-&gt;<span class=\"built_in\">Serialize</span>( *<span class=\"keyword\">this</span> );  </span><br><span class=\"line\">      &#125;   &#125;   <span class=\"function\">SIZE_T <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"type\">const</span>  </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> Num;  </span><br><span class=\"line\">   &#125;   <span class=\"function\">SIZE_T <span class=\"title\">GetMax</span><span class=\"params\">()</span> <span class=\"type\">const</span>  </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;  </span><br><span class=\"line\">      <span class=\"keyword\">return</span> Max;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">CountBytes</span><span class=\"params\">( SIZE_T InNum, SIZE_T InMax )</span> <span class=\"keyword\">override</span>  </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;  </span><br><span class=\"line\">      Num += InNum;  </span><br><span class=\"line\">      Max += InMax;  </span><br><span class=\"line\">   &#125;   <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * Returns the name of the Archive.  Useful for getting the name of the package a struct or object    * is in when a loading error occurs.    *    * This is overridden for the specific Archive Types    **/</span>   <span class=\"function\"><span class=\"keyword\">virtual</span> FString <span class=\"title\">GetArchiveName</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;FArchiveCountMem&quot;</span>); &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">protected</span>:  </span><br><span class=\"line\">   SIZE_T Num, Max;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n不难看出一般是在UObject的某个和序列化相关的函数中统计的<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UObject::Serialize</span><span class=\"params\">(FStructuredArchive::FRecord Record)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// Memory counting (with proper alignment to match C++)  </span></span><br><span class=\"line\">SIZE_T Size = <span class=\"built_in\">GetClass</span>()-&gt;<span class=\"built_in\">GetStructureSize</span>();  </span><br><span class=\"line\">UnderlyingArchive.<span class=\"built_in\">CountBytes</span>(Size, Size);</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns actual allocated size of structure in memory */</span>  </span><br><span class=\"line\"><span class=\"function\">FORCEINLINE int32 <span class=\"title\">GetStructureSize</span><span class=\"params\">()</span> <span class=\"type\">const</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">Align</span>(PropertiesSize,MinAlignment);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n  至此，我们可以得出结论：一般来说，NumKB和MaxKB的内存信息是统计<strong>被UPROPERTY宏标记的成员占用的内存</strong>。<br>  另外的情况就是涉及到网络或者<code>Serialize(FStructuredArchive::FRecord Record)</code>被重写的情况，通过查找<code>CountBytes</code>的引用，发现很多涉及到网络相关数据大小的统计也用到了这玩意。因此，具体含义可能需要具体分析，但一般情况可以默认为被UPROPERTY宏标记的成员占用的内存。  <img data-src=\"/2023/07/06/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8EMemreport%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/MemReport%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0_%E5%9B%BE%E7%89%872.png\" class=\"\" title=\"查找CountBytes的引用\"></li>\n</ul>\n","categories":["技术学习","游戏知识笔记"],"tags":["UnrealEngine学习","虚幻引擎工具相关"]}]