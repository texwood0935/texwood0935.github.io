[{"title":"NiagaraDataInterface笔记一：如何写一个NDI","url":"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/","content":"<h3 id=\"NDI简介：\"><a href=\"#NDI简介：\" class=\"headerlink\" title=\"NDI简介：\"></a>NDI简介：</h3><pre><code>Niagara是虚幻引擎推出的新的粒子系统\nNiagaraDataInterface就像Component之于Actor一样，能够通过用户自己的实现给Niagara提供许多功能\n</code></pre>\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%871.png\" class=\"\" title=\"UE自带很多NDI提供多种功能给粒子系统使用\">\n\n<h3 id=\"如何写一个NDI：\"><a href=\"#如何写一个NDI：\" class=\"headerlink\" title=\"如何写一个NDI：\"></a>如何写一个NDI：</h3><p>虽然有官方示例 ExampleCustomDataInterface的插件，但是有些函数的作用、以及一些注意点可能还是会有些不清楚。在此我使用一个更加简单的例子，来说明哪些函数的作用。</p>\n<p><strong>Let’s Start</strong></p>\n<h4 id=\"首先的准备：\"><a href=\"#首先的准备：\" class=\"headerlink\" title=\"首先的准备：\"></a>首先的准备：</h4><ol>\n<li>我们首先要在对应的模块的build.cs文件中引用<code>Niagara</code>、<code>NiagaraCore</code>两个模块 <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%872.png\" class=\"\" title=\"我们首先要在对应的模块的build.cs文件中引用&#96;Niagara&#96;、&#96;NiagaraCore&#96;两个模块\"></li>\n<li>然后对我们的NiagaraDataInterface，补充UCALSS里的声明，并且实现UObject的<code>PostInitProperties</code>接口 <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UCLASS</span>(EditInlineNew, Category = <span class=\"string\">&quot;MyNiagaraExt&quot;</span>, meta = (DisplayName = <span class=\"string\">&quot;My NDI&quot;</span>))</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NIAGARAEXT_API</span> UMyNiagaraDataInterface : <span class=\"keyword\">public</span> UNiagaraDataInterface</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"built_in\">GENERATED_BODY</span>()</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">//UObject Interface</span></span><br><span class=\"line\"><span class=\"comment\">//在这里注册NDI，以便在粒子编辑器中能看到我们的NDI</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">PostInitProperties</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//UObject Interface End</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::PostInitProperties</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">Super::<span class=\"built_in\">PostInitProperties</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">HasAnyFlags</span>(RF_ClassDefaultObject))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tENiagaraTypeRegistryFlags Flags = ENiagaraTypeRegistryFlags::AllowAnyVariable | ENiagaraTypeRegistryFlags::AllowParameter;</span><br><span class=\"line\">\tFNiagaraTypeRegistry::<span class=\"built_in\">Register</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), Flags);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n编译打开项目，我们可以在粒子编辑器中看到我们自定义的NDI了 <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%873.png\" class=\"\" title=\"我们可以在粒子编辑器中看到我们自定义的NDI了\"></li>\n</ol>\n<ul>\n<li>如果你没有看到我们自定义的NDI，请检查你的模块是否被正确加载，最简单的办法就是在<code>PostInitProperties()</code>打个断点，看看程序是否运行进去了</li>\n</ul>\n<hr>\n<h4 id=\"来写一个CPU粒子用的NDI吧：\"><a href=\"#来写一个CPU粒子用的NDI吧：\" class=\"headerlink\" title=\"来写一个CPU粒子用的NDI吧：\"></a>来写一个CPU粒子用的NDI吧：</h4><p><em>这一节中我希望我们的NDI能够在CPU粒子中被使用，并且打印一个LOG，LOG中打印一个数字</em></p>\n<h5 id=\"首先告诉NDI它能够在CPU粒子上运行吧\"><a href=\"#首先告诉NDI它能够在CPU粒子上运行吧\" class=\"headerlink\" title=\"首先告诉NDI它能够在CPU粒子上运行吧\"></a>首先告诉NDI它能够在CPU粒子上运行吧</h5><p>我们需要实现一个NDI的接口<code>CanExecuteOnTarget</code>，这个接口决定我们的NDI是否能被CPU&#x2F;GPU粒子使用。<br>因为这里我们希望实现一个CPU粒子使用的NDI，因此，实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">CanExecuteOnTarget</span><span class=\"params\">(ENiagaraSimTarget Target)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> Target == ENiagaraSimTarget::CPUSim; &#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"打印一条log吧\"><a href=\"#打印一条log吧\" class=\"headerlink\" title=\"打印一条log吧\"></a>打印一条log吧</h5><p>现在我们给我们的NDI提供一个方法，我们每调用一次这个方法打印一条log。<br>要实现这个目的，我们要实现两个接口<code>GetFunctions</code>、<code>GetVMExternalFunction</code></p>\n<ul>\n<li>GetFunctions：在这里告诉粒子系统，你的NDI能够给粒子系统提供什么方法、这些方法需要什么参数、有哪些输出；无论是CPU还是GPU粒子使用的方法都要在该接口的实现中声明；</li>\n<li>GetVMExternalFunction：在这里告诉粒子系统你在GetFunctions声明的CPU粒子用的方法，具体对应的函数是哪个<br>具体的实现如下：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctions</span><span class=\"params\">(TArray&lt;FNiagaraFunctionSignature&gt;&amp; OutFunctions)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">FNiagaraFunctionSignature Sig;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = PrintMyLogName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;PrintMyLogDescription&quot;</span>, <span class=\"string\">&quot;Print My Log.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tSig.bRequiresExecPin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetVMExternalFunction</span><span class=\"params\">(<span class=\"type\">const</span> FVMExternalFunctionBindingInfo&amp; BindingInfo, <span class=\"type\">void</span>* InstanceData, FVMExternalFunction&amp; OutFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (BindingInfo.Name == PrintMyLogName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOutFunc = FVMExternalFunction::<span class=\"built_in\">CreateLambda</span>([<span class=\"keyword\">this</span>](FVectorVMExternalFunctionContext&amp; Context) &#123; <span class=\"built_in\">UE_LOG</span>(LogNiagaraExt, Log, <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;Texwood0935 Debug My NDI: Print My Log!&quot;</span>)) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p> 编译重启项目，我们来看看效果<br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%874.png\" class=\"\" title=\"调用我们的函数\"><br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%875.png\" class=\"\" title=\"Log输出了^v^\"></p>\n<ul>\n<li>仔细观察，我们会发现节点分为可以直接执行的，和不直接执行的。他们的区别在于声明节点时<code>Sig.bRequiresExecPin</code>的值  <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%876.png\" class=\"\" title=\"两种节点\"></li>\n</ul>\n<hr>\n<h5 id=\"再加两个功能\"><a href=\"#再加两个功能\" class=\"headerlink\" title=\"再加两个功能\"></a>再加两个功能</h5><p>现在我想给我的NDI再加两个功能：设置一个变量的值以及输出一个变量<br>参照第二点，我们通过<code>GetFunctions</code>、<code>GetVMExternalFunction</code>添加并且绑定两个节点</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctions</span><span class=\"params\">(TArray&lt;FNiagaraFunctionSignature&gt;&amp; OutFunctions)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">FNiagaraFunctionSignature Sig;</span><br><span class=\"line\">&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = SetMyNumName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;SetMyNumDescription&quot;</span>, <span class=\"string\">&quot;Set My Num.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tSig.bRequiresExecPin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(FNiagaraTypeDefinition::<span class=\"built_in\">GetFloatDef</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;InputNum&quot;</span>)));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSig = <span class=\"built_in\">FNiagaraFunctionSignature</span>();</span><br><span class=\"line\">\tSig.Name = GetMyNumName;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> WITH_EDITORONLY_DATA</span></span><br><span class=\"line\">\tSig.Description = <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;GetMyNumDescription&quot;</span>, <span class=\"string\">&quot;Get My Num.&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\tSig.bMemberFunction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tSig.bSupportsGPU = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//Sig.bRequiresExecPin = true;</span></span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddInput</span>(<span class=\"built_in\">FNiagaraVariable</span>(<span class=\"built_in\">FNiagaraTypeDefinition</span>(<span class=\"built_in\">GetClass</span>()), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;My NDI&quot;</span>)));</span><br><span class=\"line\">\tSig.<span class=\"built_in\">AddOutput</span>(<span class=\"built_in\">FNiagaraVariable</span>(FNiagaraTypeDefinition::<span class=\"built_in\">GetFloatDef</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;MyNum&quot;</span>)), <span class=\"built_in\">LOCTEXT</span>(<span class=\"string\">&quot;OutputNumDescription&quot;</span>, <span class=\"string\">&quot;Returns MyNum&quot;</span>));</span><br><span class=\"line\">\tOutFunctions.<span class=\"built_in\">Add</span>(Sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">DEFINE_NDI_DIRECT_FUNC_BINDER</span>(UMyNiagaraDataInterface, SetMyNumVM);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetVMExternalFunction</span><span class=\"params\">(<span class=\"type\">const</span> FVMExternalFunctionBindingInfo&amp; BindingInfo, <span class=\"type\">void</span>* InstanceData, FVMExternalFunction&amp; OutFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (BindingInfo.Name == PrintMyLogName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BindingInfo.Name == SetMyNumName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//除了Lambda函数、通过Lambda函数调用NDI的函数，我们还可以通过宏来绑定函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">NDI_FUNC_BINDER</span>(UMyNiagaraDataInterface, SetMyNumVM)::<span class=\"built_in\">Bind</span>(<span class=\"keyword\">this</span>, OutFunc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BindingInfo.Name == GetMyNumName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOutFunc = FVMExternalFunction::<span class=\"built_in\">CreateLambda</span>([<span class=\"keyword\">this</span>](FVectorVMExternalFunctionContext&amp; Context) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">GetMyNumVM</span>(Context);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SetMyNumVM</code>和<code>GetMyNumVM</code>就是我们具体的实现了，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::SetMyNumVM</span><span class=\"params\">(FVectorVMExternalFunctionContext&amp; Context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">FNDIInputParam&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">InMyNum</span><span class=\"params\">(Context)</span></span>;</span><br><span class=\"line\">MyNum = InMyNum.<span class=\"built_in\">GetAndAdvance</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetMyNumVM</span><span class=\"params\">(FVectorVMExternalFunctionContext&amp; Context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"function\">FNDIOutputParam&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">OutMyNum</span><span class=\"params\">(Context)</span></span>;</span><br><span class=\"line\">OutMyNum.<span class=\"built_in\">SetAndAdvance</span>(MyNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里要注意一点：<strong>无论是FNDIInputParam还是FNDIOutputParam他们的模板填充进去的类型都只能是和float类型同样大小的类型，除非在引擎里事先定义好</strong>。这意味着并不是所有的类型都可以作为输入或者输出来给我们使用。</p>\n<p>编译重启项目，我们来看看效果</p>\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%877.png\" class=\"\" title=\"调用我们的函数\">\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%878.png\" class=\"\" title=\"通过NiagaraDebugger我们可以看到MyNum被正确设置，并且输出\">\n\n<hr>\n<h5 id=\"不满足于此，我希望每个粒子都有属于它的”MyNum”\"><a href=\"#不满足于此，我希望每个粒子都有属于它的”MyNum”\" class=\"headerlink\" title=\"不满足于此，我希望每个粒子都有属于它的”MyNum”\"></a>不满足于此，我希望每个粒子都有属于它的”MyNum”</h5><p>每个粒子都要有属于它的”MyNum”，这意味着我们需要一个结构让每个粒子都储存一份MyNum的数据。使用一个结构体来储存：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the struct used to store our data interface data</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FMyNiagaraDataInterfaceInstanceData</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">float</span> MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于NDI我们需要干几件事：告诉NDI结构体的大小以及每个粒子都初始化一份结构体数据还有在每个粒子销毁的时候释放我们的结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> int32 <span class=\"title\">PerInstanceDataSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">sizeof</span>(FMyNiagaraDataInterfaceInstanceData); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::InitPerInstanceData</span><span class=\"params\">(<span class=\"type\">void</span>* PerInstanceData, FNiagaraSystemInstance* SystemInstance)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">\tFMyNiagaraDataInterfaceInstanceData* InstanceData = <span class=\"built_in\">new</span> (PerInstanceData) FMyNiagaraDataInterfaceInstanceData;</span><br><span class=\"line\">\tInstanceData-&gt;MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::DestroyPerInstanceData</span><span class=\"params\">(<span class=\"type\">void</span>* PerInstanceData, FNiagaraSystemInstance* SystemInstance)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFMyNiagaraDataInterfaceInstanceData* InstData = <span class=\"built_in\">static_cast</span>&lt;FMyNiagaraDataInterfaceInstanceData*&gt;(PerInstanceData);</span><br><span class=\"line\">\tInstData-&gt;~<span class=\"built_in\">FMyNiagaraDataInterfaceInstanceData</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一点要注意：<font color=\"#dd0000\">PerInstanceDataSize不为0的时候，每一个VMFunction开头一定要有<code>VectorVM::FUserPtrHandler&lt;FMyNiagaraDataInterfaceInstanceData&gt; InstData(Context)</code>，否则使用相应的方法时，会引发崩溃。</font></p>\n<p>编译重启项目，我们来看看效果<br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%879.png\" class=\"\" title=\"调用我们的函数\"><br>    <img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%8710.png\" class=\"\" title=\"每个粒子都了有属于它的MyNum\"></p>\n<hr>\n<h5 id=\"其他一些\"><a href=\"#其他一些\" class=\"headerlink\" title=\"其他一些\"></a>其他一些</h5><p>除了上面提到的一些接口，还有些比较重要的接口：</p>\n<ul>\n<li>PerInstanceTick：每个粒子的Tick。</li>\n<li>PerInstanceTickPostSimulate：与上面的Tick不同之处在于Tick的阶段、时机不同</li>\n<li>Equals：判断两个NDI是否相等</li>\n<li>CopyToInternal：将一个NDI的数据拷贝到另一个<br>上述都是一些比较重要的接口。其中，如果没有实现<code>Equals</code>、<code>CopyToInternal</code>可能会导致NDI拷贝的时候，有参数没有被正确拷贝。作者就遇到过没实现这两个接口，导致在粒子的scratch module传参错误的情况</li>\n</ul>\n<hr>\n<h4 id=\"来实现一个GPU粒子用的NDI：\"><a href=\"#来实现一个GPU粒子用的NDI：\" class=\"headerlink\" title=\"来实现一个GPU粒子用的NDI：\"></a>来实现一个GPU粒子用的NDI：</h4><p><em>这一节中我希望我们的NDI能够在GPU粒子中获取到MyNum的值</em></p>\n<h5 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h5><p>和CPU粒子的第一步相同，我们先让NDI能够在GPU粒子上运行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">CanExecuteOnTarget</span><span class=\"params\">(ENiagaraSimTarget Target)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> Target == ENiagaraSimTarget::CPUSim || Target == ENiagaraSimTarget::GPUComputeSim; &#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外GPU粒子还需要额外写Shader，因此我们还需要模块里对shader路径进行映射</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">FNiagaraExtModule::StartupModule</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// map the shader dir so we can use it in the data interface</span></span><br><span class=\"line\">\tFString NiagaraExtShaderDir = FPaths::<span class=\"built_in\">Combine</span>(FPaths::<span class=\"built_in\">GameSourceDir</span>(), <span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;NiagaraExt/Shaders&quot;</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">AddShaderSourceDirectoryMapping</span>(<span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;/NiagaraExt&quot;</span>), NiagaraExtShaderDir);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"第二步：绑定shader以及相关的hlsl函数\"><a href=\"#第二步：绑定shader以及相关的hlsl函数\" class=\"headerlink\" title=\"第二步：绑定shader以及相关的hlsl函数\"></a>第二步：绑定shader以及相关的hlsl函数</h5><p>正如一般的shader声明流程，我们首先在类里用宏声明shader参数的结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NIAGARAEXT_API</span> UMyNiagaraDataInterface : <span class=\"keyword\">public</span> UNiagaraDataInterface</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">GENERATED_BODY</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">BEGIN_SHADER_PARAMETER_STRUCT</span>(FShaderParameters, )</span><br><span class=\"line\">\t\t<span class=\"built_in\">SHADER_PARAMETER</span>(<span class=\"type\">float</span>, MyNum)</span><br><span class=\"line\">\t<span class=\"built_in\">END_SHADER_PARAMETER_STRUCT</span>()</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们实现两个绑定shader参数的接口</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::BuildShaderParameters</span><span class=\"params\">(FNiagaraShaderParametersBuilder&amp; ShaderParametersBuilder)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tShaderParametersBuilder.<span class=\"built_in\">AddNestedStruct</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::SetShaderParameters</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceSetShaderParametersContext&amp; Context)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFShaderParameters* ShaderParameters = Context.<span class=\"built_in\">GetParameterNestedStruct</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">\tShaderParameters-&gt;MyNum = MyNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再是一些有关shader编译、hlsl函数参数相关的接口</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::AppendCompileHash</span><span class=\"params\">(FNiagaraCompileHashVisitor* InVisitor)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!Super::<span class=\"built_in\">AppendCompileHash</span>(InVisitor))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tInVisitor-&gt;<span class=\"built_in\">UpdateShaderFile</span>(MyNiagaraDataInterfaceShaderFile);</span><br><span class=\"line\">\tInVisitor-&gt;<span class=\"built_in\">UpdateShaderParameters</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::GetFunctionHLSL</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceGPUParamInfo&amp; ParamInfo, <span class=\"type\">const</span> FNiagaraDataInterfaceGeneratedFunction&amp; FunctionInfo, <span class=\"type\">int</span> FunctionInstanceIndex, FString&amp; OutHLSL)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FunctionInfo.DefinitionName == GetMyNumName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::GetParameterDefinitionHLSL</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceGPUParamInfo&amp; ParamInfo, FString&amp; OutHLSL)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> TMap&lt;FString, FStringFormatArg&gt; TemplateArgs =</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"built_in\">TEXT</span>(<span class=\"string\">&quot;ParameterName&quot;</span>),\tParamInfo.DataInterfaceHLSLSymbol&#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">AppendTemplateHLSL</span>(OutHLSL, MyNiagaraDataInterfaceShaderFile, TemplateArgs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，shader中我们提供给NDI的函数以及NDI传进来的参数都需要被<code>&#123;ParameterName&#125;</code>修饰，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// when using a template ush file, we need the _&#123;ParameterName&#125; appendix on global functions and parameters, because the template can be included multiple times for different data interfaces in a system.</span></span><br><span class=\"line\"><span class=\"type\">float</span> &#123;ParameterName&#125;_MyNum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> GetMyNum_&#123;ParameterName&#125;(out <span class=\"type\">float</span> Out_MyNum)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOut_MyNum = &#123;ParameterName&#125;_MyNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，和PrimitiveComponent一样，NDI也需要一个Proxy<br>对于支持GPU粒子的NDI来说，还需要一个实现了FNiagaraDataInterfaceProxy的类以及在构造函数里为Proxy设置值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FMyNiagaraDataInterfaceProxy</span> : <span class=\"keyword\">public</span> FNiagaraDataInterfaceProxy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> int32 <span class=\"title\">PerInstanceDataPassedToRenderThreadSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">...</span><br><span class=\"line\">UMyNiagaraDataInterface::<span class=\"built_in\">UMyNiagaraDataInterface</span>(FObjectInitializer <span class=\"type\">const</span>&amp; ObjectInitializer)</span><br><span class=\"line\">\t: <span class=\"built_in\">Super</span>(ObjectInitializer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tProxy.<span class=\"built_in\">Reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">FMyNiagaraDataInterfaceProxy</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成了以上步骤会发现，虽然GPU粒子能够获得MyNum的值，但是只能获得默认值。也就是如果我改变了MyNum的值，GPU粒子获取的值并没有改变。<br>这是因为两点：</p>\n<ol>\n<li>SetShaderParameters里面不要使用原生的NDI的值，要用Proxy里面的值，因为这在RenderThread中</li>\n<li>CopyToInternal没有正确实现<br>更正完错误后，我们的代码为：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">FMyNiagaraDataInterfaceProxy</span> : <span class=\"keyword\">public</span> FNiagaraDataInterfaceProxy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> int32 <span class=\"title\">PerInstanceDataPassedToRenderThreadSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">float</span> MyNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">FMyNiagaraDataInterfaceProxy</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">FMyNiagaraDataInterfaceProxy</span>(<span class=\"type\">float</span> InMyNum) : <span class=\"built_in\">MyNum</span>(InMyNum) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UpdateMyNum</span><span class=\"params\">(<span class=\"type\">float</span> InMyNum)</span> </span>&#123; MyNum = InMyNum; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">UMyNiagaraDataInterface::CopyToInternal</span><span class=\"params\">(UNiagaraDataInterface* Destination)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!Super::<span class=\"built_in\">CopyToInternal</span>(Destination))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUMyNiagaraDataInterface* OtherTyped = <span class=\"built_in\">CastChecked</span>&lt;UMyNiagaraDataInterface&gt;(Destination);</span><br><span class=\"line\">\tOtherTyped-&gt;MyNum = MyNum;</span><br><span class=\"line\"></span><br><span class=\"line\">\tOtherTyped-&gt;<span class=\"built_in\">GetProxyAs</span>&lt;FMyNiagaraDataInterfaceProxy&gt;()-&gt;<span class=\"built_in\">UpdateMyNum</span>(MyNum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">UMyNiagaraDataInterface::SetShaderParameters</span><span class=\"params\">(<span class=\"type\">const</span> FNiagaraDataInterfaceSetShaderParametersContext&amp; Context)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFMyNiagaraDataInterfaceProxy&amp; DataInterfaceProxy = Context.<span class=\"built_in\">GetProxy</span>&lt;FMyNiagaraDataInterfaceProxy&gt;();</span><br><span class=\"line\">\tFShaderParameters* ShaderParameters = Context.<span class=\"built_in\">GetParameterNestedStruct</span>&lt;FShaderParameters&gt;();</span><br><span class=\"line\">\tShaderParameters-&gt;MyNum = DataInterfaceProxy.MyNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>编译重启项目，我们来看看效果</p>\n<img data-src=\"/2023/06/29/NiagaraDataInterface%E7%AC%94%E8%AE%B0%E4%B8%80/NDI%E4%B8%80_%E5%9B%BE%E7%89%8711.png\" class=\"\" title=\"GPU粒子获取到正确的值了\">\n\n<hr>\n","categories":["游戏知识笔记"],"tags":["UnrealEngine学习","Niagara相关"]},{"title":"虚幻引擎如何添加一个MeshPass","url":"/2023/07/01/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAMeshPass/","content":"<p>111</p>\n","categories":["游戏知识笔记"],"tags":["UnrealEngine学习","渲染相关"]},{"title":"Chaos物理学习笔记一：Chaos物理碰撞体结构","url":"/2023/07/01/Chaos%E7%89%A9%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","content":"","categories":["游戏知识笔记"],"tags":["UnrealEngine学习","Chaos物理相关"]},{"title":"虚幻引擎渲染机制学习笔记","url":"/2023/07/01/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<p><a href=\"https://www.cnblogs.com/timlly/p/14588598.html\">向往大佬有关虚幻渲染机制的博客</a></p>\n","categories":["游戏知识笔记"],"tags":["UnrealEngine学习","渲染相关"]}]